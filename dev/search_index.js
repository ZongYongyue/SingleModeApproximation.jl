var documenterSearchIndex = {"docs":
[{"location":"singlemode/#Single-Mode-Approximation","page":"Single-Mode Approximation","title":"Single-Mode Approximation","text":"This section will introduce the single-mode approximation method for calculating collective excitations from the Hartree-Fock ground state.\n\n(Content to be added)","category":"section"},{"location":"hartreefock/#Hartree-Fock-Approximation","page":"Hartree-Fock Approximation","title":"Hartree-Fock Approximation","text":"This section introduces the Hartree-Fock (HF) approximation method for obtaining self-consistent mean-field solutions of quantum many-body systems.","category":"section"},{"location":"hartreefock/#Physical-Hamiltonian","page":"Hartree-Fock Approximation","title":"Physical Hamiltonian","text":"Consider a general quantum many-body Hamiltonian consisting of one-body and two-body interaction terms:\n\nH = H_0 + H_textint\n\nwhere the one-body term (kinetic energy, external potential, etc.) is:\n\nH_0 = sum_ij t_ij  c^dagger_i c_j\n\nand the two-body interaction term is:\n\nH_textint = sum_ijkl V_ijkl  c^dagger_i c_j c^dagger_k c_l\n\nHere:\n\nc^dagger_i c_j\nare fermionic creation/annihilation operators\ni = (r_i alpha_i sigma_i)\nrepresents a complete set of quantum numbers (position, orbital, spin, etc.)\nt_ij\nis the one-body matrix element (hopping amplitude)\nV_ijkl\nis the two-body interaction matrix element in InterAll format (c^dagger c c^dagger c)","category":"section"},{"location":"hartreefock/#Mean-Field-Decomposition","page":"Hartree-Fock Approximation","title":"Mean-Field Decomposition","text":"The Hartree-Fock approximation replaces the four-fermion interaction with a quadratic form by applying Wick's theorem. For the interaction term, we perform the mean-field decomposition:\n\nc^dagger_i c_j c^dagger_k c_l approx langle c^dagger_i c_j rangle c^dagger_k c_l + c^dagger_i c_j langle c^dagger_k c_l rangle - langle c^dagger_i c_l rangle c^dagger_k c_j - c^dagger_i c_l langle c^dagger_k c_j rangle\n\nHere we omit the constant term langle c^dagger_i c_j rangle langle c^dagger_k c_l rangle as it contributes only to the total energy.","category":"section"},{"location":"hartreefock/#Green's-Function-Notation","page":"Hartree-Fock Approximation","title":"Green's Function Notation","text":"Define the one-particle Green's function (density matrix):\n\nG_ij = langle c^dagger_i c_j rangle\n\nThe mean-field Hamiltonian becomes:\n\nH_textint^textMF = sum_ijkl V_ijkl left G_ij c^dagger_k c_l + c^dagger_i c_j G_kl - G_il c^dagger_k c_j - c^dagger_i c_l G_kj right\n\nThis consists of four terms:\n\nHartree direct term 1: sum_ijkl V_ijkl G_ij c^dagger_k c_l\nHartree direct term 2: sum_ijkl V_ijkl c^dagger_i c_j G_kl\nFock exchange term 1: -sum_ijkl V_ijkl G_il c^dagger_k c_j\nFock exchange term 2: -sum_ijkl V_ijkl c^dagger_i c_l G_kj","category":"section"},{"location":"hartreefock/#Effective-Single-Particle-Hamiltonian","page":"Hartree-Fock Approximation","title":"Effective Single-Particle Hamiltonian","text":"We now express the mean-field Hamiltonian as an effective single-particle problem:\n\nH^texteff = sum_ij h_ij^texteff c^dagger_i c_j\n\nwhere the effective single-particle matrix is:\n\nh_ij^texteff = t_ij + sum_kl U_ijkl  G_kl","category":"section"},{"location":"hartreefock/#Derivation-of-U_{ijkl}","page":"Hartree-Fock Approximation","title":"Derivation of U_ijkl","text":"To obtain a unified form, we rewrite each of the four mean-field terms to isolate the operator part c^dagger_i c_j:\n\nTerm 1 (Hartree): sum_ijkl V_ijkl G_ij c^dagger_k c_l\n\nRelabel summation indices so that the operator becomes c^dagger_i c_j:\n\nOperator: c^dagger_k c_l to c^dagger_i c_j implies (kl) to (ij)\nGreen's function: G_ij to G_kl implies (ij) to (kl)\n\nResult: sum_ij c^dagger_i c_j sum_kl V_klij G_kl\n\nTerm 2 (Hartree): sum_ijkl V_ijkl c^dagger_i c_j G_kl\n\nAlready in standard form:\n\nResult: sum_ij c^dagger_i c_j sum_kl V_ijkl G_kl\n\nTerm 3 (Fock): -sum_ijkl V_ijkl G_il c^dagger_k c_j\n\nRelabel to match c^dagger_i c_j and G_kl:\n\nOperator: c^dagger_k c_j to c^dagger_i c_j implies k to i, j unchanged\nGreen's function: G_il to G_kl implies i to k, l unchanged\n\nResult: -sum_ij c^dagger_i c_j sum_kl V_kjil G_kl\n\nTerm 4 (Fock): -sum_ijkl V_ijkl c^dagger_i c_l G_kj\n\nRelabel to match c^dagger_i c_j and G_kl:\n\nOperator: c^dagger_i c_l to c^dagger_i c_j implies l to j, i unchanged\nGreen's function: G_kj to G_kl implies j to l, k unchanged\n\nResult: -sum_ij c^dagger_i c_j sum_kl V_ilkj G_kl","category":"section"},{"location":"hartreefock/#Final-Formula","page":"Hartree-Fock Approximation","title":"Final Formula","text":"Combining all four terms, we obtain the effective interaction tensor:\n\nboxedU_ijkl = V_ijkl + V_klij - V_kjil - V_ilkj\n\nFor each set of indices (ijkl), U_ijkl collects contributions from four different elements of the original interaction tensor V:\n\nPhysical interpretation:\n\nHartree terms (V_ijkl + V_klij): Direct Coulomb repulsion, treating other electrons as a static charge density\nFock terms (-V_kjil - V_ilkj): Exchange interaction arising from quantum statistics (Pauli principle)","category":"section"},{"location":"hartreefock/#Matrix-Representation","page":"Hartree-Fock Approximation","title":"Matrix Representation","text":"","category":"section"},{"location":"hartreefock/#4D-Tensor-to-2D-Matrix","page":"Hartree-Fock Approximation","title":"4D Tensor to 2D Matrix","text":"The effective interaction tensor U_ijkl is a rank-4 tensor. For efficient computation, we reshape it into a 2D matrix:\n\nU_(ij)(kl) = U_ijkl\n\nwhere the composite index (ij) runs over all pairs of single-particle states. For a system with N single-particle states:\n\n4D tensor U_ijkl: shape (N N N N)\n2D matrix U_(ij)(kl): shape (N^2 N^2)","category":"section"},{"location":"hartreefock/#Effective-Hamiltonian-Construction","page":"Hartree-Fock Approximation","title":"Effective Hamiltonian Construction","text":"In the self-consistent field iteration, we compute the effective Hamiltonian at each step:\n\nH^texteff = H_0 + U cdot G\n\nwhere:\n\nH_0\n: one-body Hamiltonian (shape N times N)\nU\n: effective interaction matrix U_(ij)(kl) (shape N^2 times N^2)\nG\n: Green's function reshaped to a vector (length N^2)\nResult: effective Hamiltonian matrix (shape N times N)","category":"section"},{"location":"hartreefock/#Self-Consistent-Field-(SCF)-Iteration","page":"Hartree-Fock Approximation","title":"Self-Consistent Field (SCF) Iteration","text":"The Hartree-Fock equations are solved iteratively:\n\nInitialize: Start with an initial guess for G_ij (random or from previous calculation)\nBuild effective Hamiltonian: h^texteff = t + U cdot G\nDiagonalize: Find eigenvalues varepsilon_n and eigenvectors nrangle of h^texteff\nUpdate Green's function:\nZero temperature: Occupy lowest N_e states G_ij = sum_n=1^N_e langle i  n rangle langle n  j rangle\nFinite temperature: Use Fermi-Dirac distribution with chemical potential mu G_ij = sum_n f(varepsilon_n - mu) langle i  n rangle langle n  j rangle where f(varepsilon) = 1(e^varepsilonT + 1) and mu is determined by particle number conservation\nCheck convergence: textRest = frac1N^2 G_textnew - G_textold\nIf textRest  epsilon, stop. Otherwise, mix and return to step 2: G leftarrow (1-alpha) G_textold + alpha G_textnew\nCalculate physical quantities:\nBand energy: E_textband = sum_i H^texteff_ii G_ii (zero T) or use grand potential (finite T)\nInteraction energy: E_textint = -frac12 G^T cdot U cdot G\nTotal energy: E_texttotal = E_textband + E_textint\nParticle number: N = sum_i G_ii\nSpin polarization: S_z = frac12 sum_i (G_iuparrowiuparrow - G_idownarrowidownarrow)","category":"section"},{"location":"hartreefock/#Implementation-Notes","page":"Hartree-Fock Approximation","title":"Implementation Notes","text":"","category":"section"},{"location":"hartreefock/#Recommended:-Direct-U-Matrix-Construction","page":"Hartree-Fock Approximation","title":"Recommended: Direct U Matrix Construction","text":"For efficient Hartree-Fock calculations, use build_U_matrix to directly construct the sparse U matrix from operators:\n\nU_matrix = build_U_matrix(dofs, interaction_ops, blocks)\n\nThis approach:\n\nSkips the intermediate V tensor (saves N⁴ memory, e.g., 1.3 TB for 30×30 system)\nDirectly generates sparse matrix representation\nApplies the 4-term formula during construction\nExploits block structure when provided\n\nFor each interaction operator V_ijkl, the function contributes to four U matrix elements:\n\nU[(i-1)*N+j, (k-1)*N+l] += V[i,j,k,l]  # Hartree term 2\nU[(k-1)*N+l, (i-1)*N+j] += V[i,j,k,l]  # Hartree term 1  (transpose)\nU[(k-1)*N+j, (i-1)*N+l] -= V[i,j,k,l]  # Fock term 3     (exchange)\nU[(i-1)*N+l, (k-1)*N+j] -= V[i,j,k,l]  # Fock term 4     (exchange)","category":"section"},{"location":"hartreefock/#Alternative:-Two-Step-Construction-via-V-Tensor","page":"Hartree-Fock Approximation","title":"Alternative: Two-Step Construction via V Tensor","text":"For debugging or small systems, you can use the two-step approach:\n\nV = build_interaction_tensor(dofs, interaction_ops)  # Dense N×N×N×N tensor\n# Then manually apply 4-term formula to build U\n\nNote: This approach requires O(N⁴) memory and is not recommended for large systems.","category":"section"},{"location":"hartreefock/#Symmetry-and-Blocking","page":"Hartree-Fock Approximation","title":"Symmetry and Blocking","text":"When the system has conserved quantum numbers (e.g., spin S_z, particle number), the effective Hamiltonian and Green's function can be block-diagonalized:\n\nUse SystemDofs with sortrule = [[conserved_dof_indices], other_dofs]\nblocks field provides index ranges for each symmetry sector\nDiagonalize each block independently for efficiency\nDrastically reduces computational cost for large systems","category":"section"},{"location":"hartreefock/#Block-Structure-and-U-Matrix-Sparsification","page":"Hartree-Fock Approximation","title":"Block Structure and U Matrix Sparsification","text":"Important: The blocks parameter optimizes the U matrix construction by exploiting the block-diagonal structure of G, not by making U itself block-diagonal.\n\nKey insight: If G is block-diagonal (e.g., spin-up and spin-down blocks), then G_kl = 0 when k and l are in different blocks. When computing:\n\nh^texteff_ij = t_ij + sum_kl U_ijkl G_kl\n\nany U_ijkl term multiplied by G_kl = 0 contributes nothing. Therefore, we can skip storing U matrix elements where (kl) are in different blocks.\n\nStorage reduction: For B equal-sized blocks, this saves approximately (1 - 1B^2) of memory and computation:\n\n2 spin blocks: 75% reduction\n4 blocks: 94% reduction\n\nImplementation: build_U_matrix(dofs, ops, blocks) only stores U_(ij)(kl) when (kl) are in the same block, creating a column-sparse (not block-diagonal) matrix optimized for multiplication with block-diagonal G.","category":"section"},{"location":"hartreefock/#Example:-Hubbard-Model","page":"Hartree-Fock Approximation","title":"Example: Hubbard Model","text":"For the single-band Hubbard model:\n\nH = -t sum_langle ij rangle sigma c^dagger_isigma c_jsigma + U sum_i n_iuparrow n_idownarrow\n\nThe on-site interaction U n_iuparrow n_idownarrow = U c^dagger_iuparrow c_iuparrow c^dagger_idownarrow c_idownarrow is implemented as:\n\n# Setup system with spin blocking\ndofs = SystemDofs([Dof(:site, N), Dof(:spin, 2)], sortrule = [[2], 1])\nonsite = bonds(lattice, (:o, :o), 0)  # On-site bonds\n\n# Generate Hubbard U operators\nU_ops = generate_twobody(dofs, onsite,\n    (delta, qn1, qn2, qn3, qn4) ->\n        (qn1.site == qn2.site == qn3.site == qn4.site) &&\n        (qn1.spin, qn2.spin, qn3.spin, qn4.spin) == (1, 1, 2, 2) ? U : 0.0,\n    order = (cdag, 1, c, 1, cdag, 1, c, 1)\n)\n\n# Build U matrix directly (recommended for large systems)\nU_matrix = build_U_matrix(dofs, U_ops, dofs.blocks)\n\n# In SCF iteration:\n# H_eff = H_0 + reshape(U_matrix * vec(G), N, N)\n\nThe build_U_matrix function automatically applies the mean-field 4-term formula and exploits the spin block structure for efficiency.","category":"section"},{"location":"hartreefock/#References","page":"Hartree-Fock Approximation","title":"References","text":"Hartree, D. R. (1928). \"The Wave Mechanics of an Atom with a Non-Coulomb Central Field\"\nFock, V. (1930). \"Näherungsmethode zur Lösung des quantenmechanischen Mehrkörperproblems\"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://raw.githubusercontent.com/ZongYongyue/SingleModeApproximation.jl/main/docs/src/logo.png\" width=\"400\">","category":"section"},{"location":"#SingleModeApproximation.jl","page":"Home","title":"SingleModeApproximation.jl","text":"SingleModeApproximation.jl is a Julia package for studying quantum many-body systems using the single-mode approximation (SMA) method. It provides a complete workflow from constructing many-body Hamiltonians to calculating collective excitations such as magnons, excitons and so on.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"The package implements a systematic approach to quantum many-body problems:\n\nHamiltonian Construction: Build many-body Hamiltonians with arbitrary degrees of freedom (spin, orbital, sublattice, valley, etc.) on various lattice geometries\nHartree-Fock Approximation: Obtain self-consistent ground states through mean-field treatment and variational minimization\nSingle-Mode Approximation: Calculate excitation spectra using momentum-dependent collective operators\n\nThis workflow follows the standard approach used in modern condensed matter physics, as exemplified in studies of topological magnons, spin-wave excitations, and collective modes in quantum materials.\n\nSee documents: https://zongyongyue.github.io/SingleModeApproximation.jl","category":"section"},{"location":"#The-Single-Mode-Approximation-Method","page":"Home","title":"The Single-Mode Approximation Method","text":"The single-mode approximation, introduced by Feynman (1954) for superfluid helium, is a powerful technique for studying collective excitations in interacting quantum systems. The key idea is to construct momentum-dependent operators that create elementary excitations from the ground state:\n\n|k⟩ = Q†_k |Ψ₀⟩\n\nwhere Q†_k is a collective operator (e.g., spin-flip operator for magnons) and |Ψ₀⟩ is the Hartree-Fock ground state. The excitation energies are obtained by solving the eigenvalue problem in the subspace of single-particle-hole excitations, often combined with the Random Phase Approximation (RPA) to include correlation effects beyond mean-field.","category":"section"},{"location":"#Physical-Applications","page":"Home","title":"Physical Applications","text":"This approach is particularly useful for calculating:\n\nMagnon spectra in magnetic systems (spin waves)\nExciton spectra in semiconductors and insulators\nPlasmon spectra in metallic systems\nCollective modes in topological materials\n\nFor example, in the context of twisted bilayer MoTe₂, the workflow proceeds as:\n\nSingle-particle Hamiltonian (tight-binding model with spin-orbit coupling)\nMean-field calculation (Hartree-Fock self-consistency)\nMagnon spectrum (RPA excitations from the magnetic ground state)","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Flexible quantum system definitions with arbitrary degrees of freedom\nLattice structures supporting square, honeycomb, triangular, kagome, and custom geometries\nSymbolic operator algebra with automatic fermionic anticommutation\nHigh-level term generators for hopping, Coulomb, Hund's coupling, exchange, pair hopping, and Ising interactions\nMatrix and tensor builders for efficient numerical calculations\nHartree-Fock solver for ground and excited states\nRPA/TDHF methods for collective excitations","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SingleModeApproximation\")\n\nOr for development:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/zongyy/SingleModeApproximation.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SingleModeApproximation\n\n# Define system with 4 sites and spin\ndofs = SystemDofs(site=1:4, spin=[:up, :dn])\n\n# Create a square lattice\nlattice = Lattice(:Square, 2, 2, pbc=true)\n\n# Generate nearest-neighbor hopping\nbonds_nn = bonds(lattice, 1)\nhopping = generate_onebody(dofs, bonds_nn, -1.0)\n\n# Build Hamiltonian matrix\nH = build_onebody_matrix(dofs, hopping)\n\n# Diagonalize to get single-particle spectrum\nusing LinearAlgebra\neigenvalues = eigvals(Hermitian(H))","category":"section"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"Pages = [\"quantumsystem.md\", \"hartreefock.md\", \"singlemode.md\"]\nDepth = 2","category":"section"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"quantumsystem: Core quantum system definitions, lattice structures, and operator algebra\ngroundstate: Ground state calculations using Hartree-Fock and mean-field methods\nexcitations: Excited state calculations using RPA, TDHF, and single-mode approximation","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use this package in your research, please cite:\n\n@software{singlemodeapproximation,\n  author = {zongyy},\n  title = {SingleModeApproximation.jl: A Julia package for quantum many-body systems},\n  year = {2025},\n  url = {https://github.com/zongyy/SingleModeApproximation.jl}\n}","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Contributions are welcome! Please feel free to submit issues or pull requests on GitHub.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License - see the LICENSE file for details.","category":"section"},{"location":"quantumsystem/#Quantum-System-Tutorial","page":"Quantum System","title":"Quantum System Tutorial","text":"","category":"section"},{"location":"quantumsystem/#Introduction","page":"Quantum System","title":"Introduction","text":"The quantumsystem module provides a flexible framework for constructing quantum many-body Hamiltonians in Julia. It is designed to:\n\nDefine quantum systems with arbitrary degrees of freedom (spin, orbital, sublattice, valley, etc.)\nConstruct lattice structures with various geometries (square, honeycomb, triangular, etc.)\nGenerate operator terms using symbolic notation with flexible orderings\nBuild matrix and tensor representations for numerical calculations\nAutomatically handle fermionic anticommutation relations and operator reordering\n\nThis tutorial demonstrates how to use the module through two cutting-edge examples from recent literature:\n\nTwisted bilayer MoTe₂ Kane-Mele model (2025): A tight-binding model with topological bands and valley-dependent complex hopping\nMulti-orbital extended Hubbard model: Including Hund's coupling, pair hopping, and orbital-dependent interactions\n\n","category":"section"},{"location":"quantumsystem/#Core-Concepts","page":"Quantum System","title":"Core Concepts","text":"","category":"section"},{"location":"quantumsystem/#1.-Quantum-Numbers-and-Degrees-of-Freedom","page":"Quantum System","title":"1. Quantum Numbers and Degrees of Freedom","text":"Quantum numbers are represented as named tuples that index the Hilbert space. The SystemDofs structure defines all quantum degrees of freedom:\n\nusing SingleModeApproximation\n\n# Example: System with site, sublattice, and valley\ndofs = SystemDofs(\n    site = 1:16,             # 16 sites\n    sublattice = [:A, :B],   # Two sublattices (honeycomb)\n    valley = [:K_plus, :K_minus]  # ±K valleys (or spin up/down)\n)\n\n# Create a quantum number\nqn = QN(site=1, sublattice=:A, valley=:K_plus)\n\n# Linear indexing\nidx = qn2linear(dofs, qn)      # Convert to linear index\nqn_back = linear2qn(dofs, idx)  # Convert back\n\nKey features:\n\nNamed tuple representation: natural mathematical notation\nAutomatic linear indexing for matrix/tensor construction\nArbitrary quantum numbers supported (spin, orbital, layer, sublattice, valley, etc.)","category":"section"},{"location":"quantumsystem/#2.-Lattice-Structure","page":"Quantum System","title":"2. Lattice Structure","text":"Lattices define spatial geometry and neighbor relationships:\n\n# Honeycomb lattice (for MoTe₂, graphene, etc.)\nlattice = Lattice(:Honeycomb, 4, 4, pbc=true)\n\n# Square lattice (for cuprates, iron-based superconductors, etc.)\nlattice = Lattice(:Square, 6, 6, pbc=true)\n\n# Get neighbor bonds\nonsite_bonds = bonds(lattice, 0)   # On-site (delta=0)\nnn_bonds = bonds(lattice, 1)       # Nearest neighbors\nnnn_bonds = bonds(lattice, 2)      # Next-nearest neighbors\n\n# Each bond contains: site indices, displacement vector\nfor bond in nn_bonds[1:3]\n    println(\"Bond: sites $(bond.i) -> $(bond.j), delta=$(bond.delta)\")\n    println(\"  Direction: \", is_positive_direction(lattice, bond.delta))\nend","category":"section"},{"location":"quantumsystem/#3.-Operators","page":"Quantum System","title":"3. Operators","text":"The module provides symbolic operator construction:\n\nc(qn): Annihilation operator at quantum number qn\ncdag(qn): Creation operator at quantum number qn\nOperators(value, op1, op2, ...): Operator product with coefficient\n\nqn1 = QN(site=1, valley=:K_plus)\nqn2 = QN(site=2, valley=:K_plus)\n\n# Hopping term: -t c†₁ c₂\nterm = Operators(-1.0, cdag(qn1), c(qn2))\n\n# Complex hopping: (0.81 - 1.32i) c†₁ c₂\nterm_complex = Operators(0.81 - 1.32im, cdag(qn1), c(qn2))\n\nDisplay in natural notation:\n\nterms = [\n    Operators(-3.49, cdag(QN(site=1, sublattice=:A)), c(QN(site=2, sublattice=:B))),\n    Operators(0.81-1.32im, cdag(QN(site=1, sublattice=:A)), c(QN(site=3, sublattice=:A)))\n]\ndisplay(terms)\n# Output:\n# Operators with 2 terms:\n#   -3.49 c†_{1,A}c_{2,B}\n#   + (0.81 - 1.32im) c†_{1,A}c_{3,A}","category":"section"},{"location":"quantumsystem/#4.-Term-Generators","page":"Quantum System","title":"4. Term Generators","text":"High-level functions generate common operator terms:\n\nOne-body generators:\n\ngenerate_onebody(dofs, bonds, value; order=(cdag, 1, c, 2))\n\ndofs: Degrees of freedom\nbonds: Spatial bonds (from lattice)\nvalue: Coefficient (Number) or function (delta, qn1, qn2) -> Number\norder: Operator pattern, e.g., (cdag, 1, c, 2) means c†₁c₂\n\nTwo-body generators:\n\ngenerate_twobody(dofs, bonds, value; order=(cdag, 1, c, 1, cdag, 2, c, 2))\n\nConvenience functions:\n\ngenerate_coulomb_intra, generate_hund, generate_ising, etc.","category":"section"},{"location":"quantumsystem/#5.-Matrix/Tensor-Construction","page":"Quantum System","title":"5. Matrix/Tensor Construction","text":"# One-body Hamiltonian matrix\nH_matrix = build_onebody_matrix(dofs, onebody_terms)\n\n# Two-body interaction tensor\nV_tensor = build_interaction_tensor(dofs, twobody_terms)\n\n","category":"section"},{"location":"quantumsystem/#Example-1:-Twisted-Bilayer-MoTe-Kane-Mele-Model","page":"Quantum System","title":"Example 1: Twisted Bilayer MoTe₂ Kane-Mele Model","text":"Reference: Qiu & Wu, Topological magnons and domain walls in twisted bilayer MoTe₂, Phys. Rev. B 112, 085132 (2025)","category":"section"},{"location":"quantumsystem/#Model-Description","page":"Quantum System","title":"Model Description","text":"The tight-binding Hamiltonian for twisted bilayer MoTe₂ projected onto Wannier states is:\n\n$\n\n\\hat{H}{KM} = \\sum{\\tau, \\alpha\\beta, RR'} t^\\tau{\\alpha\\beta}(R-R') b^\\dagger{R\\alpha\\tau} b_{R'\\beta\\tau} $\n\nwhere:\n\nb^dagger_Ralphatau\ncreates a hole at moiré unit cell R, sublattice alpha (A or B), valley tau (± or equivalently spin ↑↓)\nt^tau_alphabeta(R-R)\nare hopping parameters up to 5th nearest neighbors\n\nKey features:\n\nNearest-neighbor hopping t_1: Real, connects A-B sublattices\nNext-nearest-neighbor hopping t_2: Complex with phase factor e^iphi_t tau nu_ij\ntau = pm\nfor valley (spin-valley locking)\nnu_ij = +1\nif hopping follows dashed arrows in Fig. 1, -1 if against\nExtended hoppings t_3 t_4 t_5: Connect further neighbors\n\nThis is a generalized Kane-Mele model - two copies of time-reversal partner Haldane models - leading to topological Chern bands.\n\nParameters at twist angle θ = 3.5° (from Fig. 1):\n\nt_1 = -349\nmeV (nearest neighbor, real)\nt_2 = 081 - 132i\nmeV (next-nearest neighbor, complex with direction-dependent phase)\nt_3 = 072\nmeV\nt_4 = -026\nmeV\nt_5 = 008\nmeV","category":"section"},{"location":"quantumsystem/#Implementation","page":"Quantum System","title":"Implementation","text":"using SingleModeApproximation\nusing LinearAlgebra\n\n# ========================================\n# System setup\n# ========================================\nLx, Ly = 4, 4\nlattice = Lattice(:Honeycomb, Lx, Ly, pbc=true)\nnsites = lattice.nsites\n\n# Degrees of freedom: site, sublattice (A/B), valley (± or ↑↓)\n# Valley ± is locked to spin ↑↓ in MoTe₂\ndofs = SystemDofs(\n    site = 1:nsites,\n    sublattice = [:A, :B],\n    valley = [:plus, :minus]  # τ = ± (or equivalently spin ↑↓)\n)\n\nprintln(\"Twisted MoTe₂ Kane-Mele model\")\nprintln(\"System size: $nsites sites\")\nprintln(\"Hilbert space dimension: \", length(dofs))\n\n# ========================================\n# Parameters (from Qiu & Wu, PRB 2025, Fig. 1, θ = 3.5°)\n# ========================================\nt1 = -3.49          # meV, nearest-neighbor (real)\nt2_mag = 0.81       # meV, magnitude of next-nearest-neighbor\nt2_phase = -1.32    # meV, imaginary part (encodes φ_t and direction)\nt3 = 0.72           # meV\nt4 = -0.26          # meV\nt5 = 0.08           # meV\n\n# ========================================\n# 1. Nearest-neighbor hopping: t1 (A-B)\n# ========================================\nnn_bonds = bonds(lattice, 1)\n\nfunction nn_hopping(delta, qn1, qn2)\n    # t1 connects A to B sublattices only\n    # Same valley (no valley mixing)\n    if qn1.sublattice != qn2.sublattice && qn1.valley == qn2.valley\n        return t1\n    end\n    return 0.0\nend\n\nt1_terms = generate_onebody(\n    dofs, nn_bonds, nn_hopping;\n    order = (cdag, 1, c, 2)\n)\n\n# ========================================\n# 2. Next-nearest-neighbor hopping: t2 (A-A or B-B)\n#    Complex with valley and direction dependent phase\n# ========================================\nnnn_bonds = bonds(lattice, 2)\n\nfunction nnn_hopping(delta, qn1, qn2)\n    # t2 connects same sublattice (A-A or B-B)\n    # Has phase factor: exp(i φ_t τ ν_ij)\n    if qn1.sublattice == qn2.sublattice && qn1.valley == qn2.valley\n        # Determine τ: +1 for valley=plus, -1 for valley=minus\n        tau = (qn1.valley == :plus) ? 1 : -1\n\n        # Determine ν_ij based on hopping direction\n        # On honeycomb lattice, next-nearest neighbors have specific directions\n        # ν_ij = +1 if following clockwise path around hexagon, -1 if counterclockwise\n        # This is encoded in delta and sublattice\n        # For honeycomb lattice, use displacement vector to determine circulation\n\n        # Get coordinates to determine direction\n        coord1 = get_coordinate(lattice, qn1.site)\n        coord2 = get_coordinate(lattice, qn2.site)\n        displacement = coord2 - coord1\n\n        # Determine circulation based on displacement and sublattice\n        # This follows the dashed arrows in Fig. 1 of the paper\n        # Simplified version: use cross product with reference direction\n        # For sublattice A: counterclockwise is positive\n        # For sublattice B: clockwise is positive\n        if qn1.sublattice == :A\n            # Example criterion (adjust based on actual lattice geometry)\n            nu_ij = (displacement[1] * 0.5 + displacement[2] > 0) ? 1 : -1\n        else  # sublattice B\n            nu_ij = (displacement[1] * 0.5 + displacement[2] > 0) ? -1 : 1\n        end\n\n        # Phase factor: exp(i φ_t τ ν_ij)\n        # From t2 = 0.81 - 1.32i, we extract the phase\n        # t2 = |t2| * exp(i * arg(t2)) = |t2| * exp(i φ_t τ ν_ij)\n        # For simplicity, use the full complex t2 with direction dependence\n        phase_factor = tau * nu_ij\n        t2_complex = (t2_mag + im * t2_phase)\n\n        # Apply phase: if phase_factor is negative, take complex conjugate\n        if phase_factor > 0\n            return t2_complex\n        else\n            return conj(t2_complex)\n        end\n    end\n    return 0.0\nend\n\nt2_terms = generate_onebody(\n    dofs, nnn_bonds, nnn_hopping;\n    order = (cdag, 1, c, 2)\n)\n\n# ========================================\n# 3. Third-nearest-neighbor hopping: t3\n# ========================================\ntn3_bonds = bonds(lattice, 3)\n\nfunction t3_hopping(delta, qn1, qn2)\n    # Real hopping, same valley\n    if qn1.valley == qn2.valley\n        return t3\n    end\n    return 0.0\nend\n\nt3_terms = generate_onebody(\n    dofs, tn3_bonds, t3_hopping;\n    order = (cdag, 1, c, 2)\n)\n\n# ========================================\n# 4. Fourth-nearest-neighbor hopping: t4\n# ========================================\ntn4_bonds = bonds(lattice, 4)\n\nfunction t4_hopping(delta, qn1, qn2)\n    if qn1.valley == qn2.valley\n        return t4\n    end\n    return 0.0\nend\n\nt4_terms = generate_onebody(\n    dofs, tn4_bonds, t4_hopping;\n    order = (cdag, 1, c, 2)\n)\n\n# ========================================\n# 5. Fifth-nearest-neighbor hopping: t5\n# ========================================\ntn5_bonds = bonds(lattice, 5)\n\nfunction t5_hopping(delta, qn1, qn2)\n    if qn1.valley == qn2.valley\n        return t5\n    end\n    return 0.0\nend\n\nt5_terms = generate_onebody(\n    dofs, tn5_bonds, t5_hopping;\n    order = (cdag, 1, c, 2)\n)\n\n# ========================================\n# 6. Coulomb interactions (optional)\n# ========================================\nonsite_bonds = bonds(lattice, 0)\nU = 10.0  # On-site Coulomb repulsion (meV)\n\ncoulomb_terms = generate_coulomb_intra(dofs, onsite_bonds, U)\n\n# ========================================\n# Combine all hopping terms\n# ========================================\nall_hopping_terms = vcat(\n    t1_terms,\n    t2_terms,\n    t3_terms,\n    t4_terms,\n    t5_terms\n)\n\n# Build one-body Hamiltonian\nH_KM = build_onebody_matrix(dofs, all_hopping_terms)\nV_int = build_interaction_tensor(dofs, coulomb_terms)\n\n# ========================================\n# Analysis\n# ========================================\nprintln(\"\\n\" * \"=\"^70)\nprintln(\"Twisted Bilayer MoTe₂: Kane-Mele Model (Eq. 2 from PRB 112, 085132)\")\nprintln(\"=\"^70)\nprintln(\"Parameters at θ = 3.5°:\")\nprintln(\"  t1 = $t1 meV (NN, real)\")\nprintln(\"  t2 = $(t2_mag) + $(t2_phase)i meV (NNN, complex)\")\nprintln(\"  t3 = $t3 meV\")\nprintln(\"  t4 = $t4 meV\")\nprintln(\"  t5 = $t5 meV\")\nprintln(\"  U = $U meV (on-site Coulomb)\")\n\nprintln(\"\\nSystem properties:\")\nprintln(\"  Lattice: Honeycomb $(Lx)×$(Ly), $nsites sites\")\nprintln(\"  Hilbert space: \", size(H_KM, 1), \" states\")\nprintln(\"  Hopping terms: \", length(all_hopping_terms))\nprintln(\"    - t1 (NN): \", length(t1_terms))\nprintln(\"    - t2 (NNN): \", length(t2_terms))\nprintln(\"    - t3: \", length(t3_terms))\nprintln(\"    - t4: \", length(t4_terms))\nprintln(\"    - t5: \", length(t5_terms))\nprintln(\"  Interaction terms: \", length(coulomb_terms))\n\n# Diagonalize and analyze spectrum\neigenvalues = eigvals(Hermitian(H_KM))\nprintln(\"\\nOne-body band structure:\")\nprintln(\"  Bandwidth: $(rd(maximum(real(eigenvalues)) - minimum(real(eigenvalues)))) meV\")\nprintln(\"  Energy range: [$(rd(minimum(real(eigenvalues)))), $(rd(maximum(real(eigenvalues))))] meV\")\n\n# Check if there's a gap (topological bands have gaps)\nsorted_eigs = sort(real(eigenvalues))\nmid_idx = length(sorted_eigs) ÷ 2\nif mid_idx > 0 && mid_idx < length(sorted_eigs)\n    gap = sorted_eigs[mid_idx+1] - sorted_eigs[mid_idx]\n    println(\"  Gap around Fermi level: $(rd(gap)) meV\")\nend\n\n# Check Hermiticity\nhermiticity_error = norm(H_KM - H_KM')\nprintln(\"\\nHermiticity check: ||H - H†|| = $(hermiticity_error)\")\n\n# Display sample terms\nprintln(\"\\n\" * \"-\"^70)\nprintln(\"Sample t1 (nearest-neighbor) terms:\")\nprintln(\"-\"^70)\ndisplay(t1_terms[1:min(4, length(t1_terms))])\n\nprintln(\"\\n\" * \"-\"^70)\nprintln(\"Sample t2 (next-nearest-neighbor, complex) terms:\")\nprintln(\"-\"^70)\ndisplay(t2_terms[1:min(4, length(t2_terms))])","category":"section"},{"location":"quantumsystem/#Key-Features-Explained","page":"Quantum System","title":"Key Features Explained","text":"Valley-dependent phase (Kane-Mele mechanism):\nNext-nearest-neighbor hopping t_2 has phase factor e^iphi_t tau nu_ij\ntau = pm\ndistinguishes ±K valleys (or spin ↑↓)\nnu_ij = pm 1\ndepends on circulation direction around hexagon\nThis breaks time-reversal within each valley but preserves combined mathcalT symmetry\nLeads to opposite Chern numbers ±1 in the two valleys\nTopological properties:\nTwo moiré valence bands with Chern numbers ±1 per valley\nQuantum anomalous Hall effect at ν = 1 filling\nTopological magnon excitations with chiral edge states\nWannier basis:\nA sublattice: polarized to top layer (t)\nB sublattice: polarized to bottom layer (b)\nReflects layer-sublattice locking in twisted system","category":"section"},{"location":"quantumsystem/#Extensions-and-Applications","page":"Quantum System","title":"Extensions and Applications","text":"This model serves as the foundation for studying:\n\nTopological magnons (intervalley spin-flip excitations with Chern numbers)\nDomain walls between regions with opposite Chern numbers\nFractional quantum anomalous Hall states at other fillings\nMagnetic ordering temperature via effective spin models\n\n","category":"section"},{"location":"quantumsystem/#Example-2:-Multi-Orbital-Extended-Hubbard-Model","page":"Quantum System","title":"Example 2: Multi-Orbital Extended Hubbard Model","text":"","category":"section"},{"location":"quantumsystem/#Model-Description-2","page":"Quantum System","title":"Model Description","text":"The multi-orbital extended Hubbard model describes strongly correlated systems with multiple orbitals per site. The Hamiltonian includes:\n\n$\n\nH = \\sum{ii', mm', \\sigma} t^{ii'}{mm'} c^\\dagger{im\\sigma} c{i'm'\\sigma} + H_{\\text{int}} $\n\nThe interaction part can be decomposed as:\n\n$\n\nH{\\text{int}} = \\sumi \\left[ \\summ U n{m\\uparrow} n{m\\downarrow} + \\sum{m \\neq m', \\sigma\\sigma'} U' n{m\\sigma} n{m'\\sigma'} + \\sum{m \\neq m'} J c^\\dagger{m\\uparrow} c^\\dagger{m\\downarrow} c{m'\\downarrow} c{m'\\uparrow} - \\sum{m \\neq m'} J c^\\dagger{m\\uparrow} c{m\\downarrow} c^\\dagger{m'\\downarrow} c{m'\\uparrow} \\right] $\n\nwhere:\n\nU: Intra-orbital Coulomb repulsion\nU': Inter-orbital Coulomb repulsion\nJ: Hund's coupling (favors parallel spins) and spin-exchange term","category":"section"},{"location":"quantumsystem/#Implementation-2","page":"Quantum System","title":"Implementation","text":"using SingleModeApproximation\nusing LinearAlgebra\n\n# ========================================\n# System setup\n# ========================================\nLx, Ly = 4, 4\nlattice = Lattice(:Square, Lx, Ly, pbc=true)\nnsites = lattice.nsites\n\n# Parameters\nt1 = 1.0      # Hopping for orbital 1 (eV)\nt2 = 0.8      # Hopping for orbital 2 (eV)\nt12 = 0.2     # Inter-orbital hopping (eV)\nU1 = 4.0      # Intra-orbital Coulomb for orbital 1 (eV)\nU2 = 3.5      # Intra-orbital Coulomb for orbital 2 (eV)\nU_prime = 2.0 # Inter-orbital Coulomb (eV)\nJ_H = 0.6     # Hund's coupling (eV)\n\n# Degrees of freedom\ndofs = SystemDofs(\n    site = 1:nsites,\n    orbital = 1:2,\n    spin = [:up, :dn]\n)\n\nprintln(\"Multi-Orbital Extended Hubbard Model on $(Lx)×$(Ly) square lattice\")\nprintln(\"Hilbert space dimension: \", length(dofs))\n\n# ========================================\n# ONE-BODY TERMS\n# ========================================\nnn_bonds = bonds(lattice, 1)\nonsite_bonds = bonds(lattice, 0)\n\n# Intra-orbital hopping\nfunction intra_hopping(delta, qn1, qn2)\n    if qn1.orbital == qn2.orbital\n        return (qn1.orbital == 1) ? -t1 : -t2\n    end\n    return 0.0\nend\n\nhopping_intra = generate_onebody(dofs, nn_bonds, intra_hopping;\n    order = (cdag, 1, c, 2))\n\n# Inter-orbital hopping\nfunction inter_hopping(delta, qn1, qn2)\n    return (qn1.orbital != qn2.orbital) ? -t12 : 0.0\nend\n\nhopping_inter = generate_onebody(dofs, nn_bonds, inter_hopping;\n    order = (cdag, 1, c, 2))\n\n# ========================================\n# TWO-BODY INTERACTION TERMS\n# ========================================\n\n# Intra-orbital Coulomb: U n_{m↑} n_{m↓}\nfunction intra_coulomb(delta, qn1, qn2, qn3, qn4)\n    if (qn1.orbital == qn2.orbital == qn3.orbital == qn4.orbital &&\n        qn1.spin != qn2.spin)\n        return (qn1.orbital == 1) ? U1 : U2\n    end\n    return 0.0\nend\n\ncoulomb_intra = generate_twobody(dofs, onsite_bonds, intra_coulomb;\n    order = (cdag, 1, c, 1, cdag, 2, c, 2))\n\n# Inter-orbital Coulomb: U' n_{mσ} n_{m'σ'}\nfunction inter_coulomb(delta, qn1, qn2, qn3, qn4)\n    return (qn1.orbital != qn3.orbital) ? U_prime : 0.0\nend\n\ncoulomb_inter = generate_twobody(dofs, onsite_bonds, inter_coulomb;\n    order = (cdag, 1, c, 1, cdag, 2, c, 2))\n\n# Hund's coupling and spin exchange\nhund_terms = generate_hund(dofs, onsite_bonds, J_H)\n\n# ========================================\n# Build Hamiltonians\n# ========================================\nhopping_terms = vcat(hopping_intra, hopping_inter)\ninteraction_terms = vcat(coulomb_intra, coulomb_inter, hund_terms)\n\nH_onebody = build_onebody_matrix(dofs, hopping_terms)\nV_twobody = build_interaction_tensor(dofs, interaction_terms)\n\n# ========================================\n# Analysis\n# ========================================\nprintln(\"\\n\" * \"=\"^70)\nprintln(\"Multi-Orbital Extended Hubbard Model\")\nprintln(\"=\"^70)\nprintln(\"Parameters:\")\nprintln(\"  t1 = $t1 eV, t2 = $t2 eV, t12 = $t12 eV\")\nprintln(\"  U1 = $U1 eV, U2 = $U2 eV, U' = $U_prime eV, J = $J_H eV\")\n\nprintln(\"\\nSystem properties:\")\nprintln(\"  One-body terms: \", length(hopping_terms))\nprintln(\"  Two-body terms: \", length(interaction_terms))\nprintln(\"  Matrix size: \", size(H_onebody))\nprintln(\"  Tensor size: \", size(V_twobody))\n\neigenvalues = eigvals(Hermitian(H_onebody))\nprintln(\"\\nOne-body spectrum:\")\nprintln(\"  Bandwidth: $(rd(maximum(real(eigenvalues)) - minimum(real(eigenvalues)))) eV\")\n\nprintln(\"\\nSample Hund's coupling terms:\")\ndisplay(hund_terms[1:min(4, length(hund_terms))])","category":"section"},{"location":"quantumsystem/#Key-Features","page":"Quantum System","title":"Key Features","text":"Orbital differentiation: Each orbital has distinct hopping and Coulomb U\nHund's coupling: Favors high-spin configurations (parallel spins in different orbitals)\nRich phase diagram: Competition between U, U', J drives various orders\n\n","category":"section"},{"location":"quantumsystem/#Summary","page":"Quantum System","title":"Summary","text":"The quantumsystem module enables rapid construction of quantum many-body Hamiltonians:\n\n✅ Flexible degrees of freedom - valleys, orbitals, sublattices, spins ✅ Complex parameters - direction-dependent phases, valley-dependent couplings ✅ Automatic sign handling - fermionic anticommutation built-in ✅ Topological models - Kane-Mele, Haldane, Chern insulators ✅ Strong correlations - Extended Hubbard, Hund's coupling","category":"section"},{"location":"quantumsystem/#Typical-Workflow","page":"Quantum System","title":"Typical Workflow","text":"Define SystemDofs and Lattice\nUse generate_onebody/generate_twobody with value functions\nBuild matrices with build_onebody_matrix/build_interaction_tensor\nSolve using diagonalization, DMFT, ED, DMRG, etc.\n\nThis framework accelerates research in twisted moiré materials, topological insulators, and strongly correlated systems!","category":"section"},{"location":"quantumsystem/#References","page":"Quantum System","title":"References","text":"Qiu, W.-X. & Wu, F., Topological magnons and domain walls in twisted bilayer MoTe₂, Phys. Rev. B 112, 085132 (2025)","category":"section"}]
}
