<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hartree-Fock Approximation · SingleModeApproximation.jl</title><meta name="title" content="Hartree-Fock Approximation · SingleModeApproximation.jl"/><meta property="og:title" content="Hartree-Fock Approximation · SingleModeApproximation.jl"/><meta property="twitter:title" content="Hartree-Fock Approximation · SingleModeApproximation.jl"/><meta name="description" content="Documentation for SingleModeApproximation.jl."/><meta property="og:description" content="Documentation for SingleModeApproximation.jl."/><meta property="twitter:description" content="Documentation for SingleModeApproximation.jl."/><meta property="og:url" content="https://zongyy.github.io/SingleModeApproximation.jl/hartreefock/"/><meta property="twitter:url" content="https://zongyy.github.io/SingleModeApproximation.jl/hartreefock/"/><link rel="canonical" href="https://zongyy.github.io/SingleModeApproximation.jl/hartreefock/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SingleModeApproximation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quantumsystem/">Quantum System</a></li><li class="is-active"><a class="tocitem" href>Hartree-Fock Approximation</a><ul class="internal"><li><a class="tocitem" href="#Physical-Hamiltonian"><span>Physical Hamiltonian</span></a></li><li><a class="tocitem" href="#Mean-Field-Decomposition"><span>Mean-Field Decomposition</span></a></li><li><a class="tocitem" href="#Effective-Single-Particle-Hamiltonian"><span>Effective Single-Particle Hamiltonian</span></a></li><li><a class="tocitem" href="#Matrix-Representation"><span>Matrix Representation</span></a></li><li><a class="tocitem" href="#Self-Consistent-Field-(SCF)-Iteration"><span>Self-Consistent Field (SCF) Iteration</span></a></li><li><a class="tocitem" href="#Implementation-Notes"><span>Implementation Notes</span></a></li><li><a class="tocitem" href="#Example:-Hubbard-Model"><span>Example: Hubbard Model</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../singlemode/">Single-Mode Approximation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Hartree-Fock Approximation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hartree-Fock Approximation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/zongyy/SingleModeApproximation.jl/blob/main/docs/src/hartreefock.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hartree-Fock-Approximation"><a class="docs-heading-anchor" href="#Hartree-Fock-Approximation">Hartree-Fock Approximation</a><a id="Hartree-Fock-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Hartree-Fock-Approximation" title="Permalink"></a></h1><p>This section introduces the Hartree-Fock (HF) approximation method for obtaining self-consistent mean-field solutions of quantum many-body systems.</p><h2 id="Physical-Hamiltonian"><a class="docs-heading-anchor" href="#Physical-Hamiltonian">Physical Hamiltonian</a><a id="Physical-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Hamiltonian" title="Permalink"></a></h2><p>Consider a general quantum many-body Hamiltonian consisting of one-body and two-body interaction terms:</p><p class="math-container">\[H = H_0 + H_{\text{int}}\]</p><p>where the one-body term (kinetic energy, external potential, etc.) is:</p><p class="math-container">\[H_0 = \sum_{ij} t_{ij} \, c^\dagger_i c_j\]</p><p>and the two-body interaction term is:</p><p class="math-container">\[H_{\text{int}} = \sum_{ijkl} V_{ijkl} \, c^\dagger_i c_j c^\dagger_k c_l\]</p><p>Here:</p><ul><li><p class="math-container">\[c^\dagger_i, c_j\]</p>are fermionic creation/annihilation operators</li><li><p class="math-container">\[i = (r_i, \alpha_i, \sigma_i)\]</p>represents a complete set of quantum numbers (position, orbital, spin, etc.)</li><li><p class="math-container">\[t_{ij}\]</p>is the one-body matrix element (hopping amplitude)</li><li><p class="math-container">\[V_{ijkl}\]</p>is the two-body interaction matrix element in <strong>InterAll format</strong> (<span>$c^\dagger c c^\dagger c$</span>)</li></ul><h2 id="Mean-Field-Decomposition"><a class="docs-heading-anchor" href="#Mean-Field-Decomposition">Mean-Field Decomposition</a><a id="Mean-Field-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Field-Decomposition" title="Permalink"></a></h2><p>The Hartree-Fock approximation replaces the four-fermion interaction with a quadratic form by applying <strong>Wick&#39;s theorem</strong>. For the interaction term, we perform the mean-field decomposition:</p><p class="math-container">\[c^\dagger_i c_j c^\dagger_k c_l \approx \langle c^\dagger_i c_j \rangle c^\dagger_k c_l + c^\dagger_i c_j \langle c^\dagger_k c_l \rangle - \langle c^\dagger_i c_l \rangle c^\dagger_k c_j - c^\dagger_i c_l \langle c^\dagger_k c_j \rangle\]</p><p>Here we omit the constant term <span>$\langle c^\dagger_i c_j \rangle \langle c^\dagger_k c_l \rangle$</span> as it contributes only to the total energy.</p><h3 id="Green&#39;s-Function-Notation"><a class="docs-heading-anchor" href="#Green&#39;s-Function-Notation">Green&#39;s Function Notation</a><a id="Green&#39;s-Function-Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Green&#39;s-Function-Notation" title="Permalink"></a></h3><p>Define the one-particle Green&#39;s function (density matrix):</p><p class="math-container">\[G_{ij} = \langle c^\dagger_i c_j \rangle\]</p><p>The mean-field Hamiltonian becomes:</p><p class="math-container">\[H_{\text{int}}^{\text{MF}} = \sum_{ijkl} V_{ijkl} \left[ G_{ij} c^\dagger_k c_l + c^\dagger_i c_j G_{kl} - G_{il} c^\dagger_k c_j - c^\dagger_i c_l G_{kj} \right]\]</p><p>This consists of <strong>four terms</strong>:</p><ol><li><strong>Hartree direct term 1</strong>: <span>$\sum_{ijkl} V_{ijkl} G_{ij} c^\dagger_k c_l$</span></li><li><strong>Hartree direct term 2</strong>: <span>$\sum_{ijkl} V_{ijkl} c^\dagger_i c_j G_{kl}$</span></li><li><strong>Fock exchange term 1</strong>: <span>$-\sum_{ijkl} V_{ijkl} G_{il} c^\dagger_k c_j$</span></li><li><strong>Fock exchange term 2</strong>: <span>$-\sum_{ijkl} V_{ijkl} c^\dagger_i c_l G_{kj}$</span></li></ol><h2 id="Effective-Single-Particle-Hamiltonian"><a class="docs-heading-anchor" href="#Effective-Single-Particle-Hamiltonian">Effective Single-Particle Hamiltonian</a><a id="Effective-Single-Particle-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Effective-Single-Particle-Hamiltonian" title="Permalink"></a></h2><p>We now express the mean-field Hamiltonian as an effective single-particle problem:</p><p class="math-container">\[H^{\text{eff}} = \sum_{ij} h_{ij}^{\text{eff}} c^\dagger_i c_j\]</p><p>where the effective single-particle matrix is:</p><p class="math-container">\[h_{ij}^{\text{eff}} = t_{ij} + \sum_{kl} U_{ijkl} \, G_{kl}\]</p><h3 id="Derivation-of-U_{ijkl}"><a class="docs-heading-anchor" href="#Derivation-of-U_{ijkl}">Derivation of <span>$U_{ijkl}$</span></a><a id="Derivation-of-U_{ijkl}-1"></a><a class="docs-heading-anchor-permalink" href="#Derivation-of-U_{ijkl}" title="Permalink"></a></h3><p>To obtain a unified form, we rewrite each of the four mean-field terms to isolate the operator part <span>$c^\dagger_i c_j$</span>:</p><p><strong>Term 1 (Hartree)</strong>: <span>$\sum_{ijkl} V_{ijkl} G_{ij} c^\dagger_k c_l$</span></p><p>Relabel summation indices so that the operator becomes <span>$c^\dagger_i c_j$</span>:</p><ul><li>Operator: <span>$c^\dagger_k c_l \to c^\dagger_i c_j$</span> implies <span>$(k,l) \to (i,j)$</span></li><li>Green&#39;s function: <span>$G_{ij} \to G_{kl}$</span> implies <span>$(i,j) \to (k,l)$</span></li></ul><p>Result: <span>$\sum_{ij} c^\dagger_i c_j \sum_{kl} V_{klij} G_{kl}$</span></p><p><strong>Term 2 (Hartree)</strong>: <span>$\sum_{ijkl} V_{ijkl} c^\dagger_i c_j G_{kl}$</span></p><p>Already in standard form:</p><p>Result: <span>$\sum_{ij} c^\dagger_i c_j \sum_{kl} V_{ijkl} G_{kl}$</span></p><p><strong>Term 3 (Fock)</strong>: <span>$-\sum_{ijkl} V_{ijkl} G_{il} c^\dagger_k c_j$</span></p><p>Relabel to match <span>$c^\dagger_i c_j$</span> and <span>$G_{kl}$</span>:</p><ul><li>Operator: <span>$c^\dagger_k c_j \to c^\dagger_i c_j$</span> implies <span>$k \to i$</span>, <span>$j$</span> unchanged</li><li>Green&#39;s function: <span>$G_{il} \to G_{kl}$</span> implies <span>$i \to k$</span>, <span>$l$</span> unchanged</li></ul><p>Result: <span>$-\sum_{ij} c^\dagger_i c_j \sum_{kl} V_{kjil} G_{kl}$</span></p><p><strong>Term 4 (Fock)</strong>: <span>$-\sum_{ijkl} V_{ijkl} c^\dagger_i c_l G_{kj}$</span></p><p>Relabel to match <span>$c^\dagger_i c_j$</span> and <span>$G_{kl}$</span>:</p><ul><li>Operator: <span>$c^\dagger_i c_l \to c^\dagger_i c_j$</span> implies <span>$l \to j$</span>, <span>$i$</span> unchanged</li><li>Green&#39;s function: <span>$G_{kj} \to G_{kl}$</span> implies <span>$j \to l$</span>, <span>$k$</span> unchanged</li></ul><p>Result: <span>$-\sum_{ij} c^\dagger_i c_j \sum_{kl} V_{ilkj} G_{kl}$</span></p><h3 id="Final-Formula"><a class="docs-heading-anchor" href="#Final-Formula">Final Formula</a><a id="Final-Formula-1"></a><a class="docs-heading-anchor-permalink" href="#Final-Formula" title="Permalink"></a></h3><p>Combining all four terms, we obtain the <strong>effective interaction tensor</strong>:</p><p class="math-container">\[\boxed{U_{ijkl} = V_{ijkl} + V_{klij} - V_{kjil} - V_{ilkj}}\]</p><p>For each set of indices <span>$(i,j,k,l)$</span>, <span>$U_{ijkl}$</span> collects contributions from four different elements of the original interaction tensor <span>$V$</span>:</p><p><strong>Physical interpretation</strong>:</p><ul><li><strong>Hartree terms</strong> (<span>$V_{ijkl} + V_{klij}$</span>): Direct Coulomb repulsion, treating other electrons as a static charge density</li><li><strong>Fock terms</strong> (<span>$-V_{kjil} - V_{ilkj}$</span>): Exchange interaction arising from quantum statistics (Pauli principle)</li></ul><h2 id="Matrix-Representation"><a class="docs-heading-anchor" href="#Matrix-Representation">Matrix Representation</a><a id="Matrix-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Representation" title="Permalink"></a></h2><h3 id="4D-Tensor-to-2D-Matrix"><a class="docs-heading-anchor" href="#4D-Tensor-to-2D-Matrix">4D Tensor to 2D Matrix</a><a id="4D-Tensor-to-2D-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#4D-Tensor-to-2D-Matrix" title="Permalink"></a></h3><p>The effective interaction tensor <span>$U_{ijkl}$</span> is a rank-4 tensor. For efficient computation, we reshape it into a 2D matrix:</p><p class="math-container">\[U_{(i,j),(k,l)} = U_{ijkl}\]</p><p>where the composite index <span>$(i,j)$</span> runs over all pairs of single-particle states. For a system with <span>$N$</span> single-particle states:</p><ul><li>4D tensor <span>$U_{ijkl}$</span>: shape <span>$(N, N, N, N)$</span></li><li>2D matrix <span>$U_{(i,j),(k,l)}$</span>: shape <span>$(N^2, N^2)$</span></li></ul><h3 id="Effective-Hamiltonian-Construction"><a class="docs-heading-anchor" href="#Effective-Hamiltonian-Construction">Effective Hamiltonian Construction</a><a id="Effective-Hamiltonian-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Effective-Hamiltonian-Construction" title="Permalink"></a></h3><p>In the self-consistent field iteration, we compute the effective Hamiltonian at each step:</p><p class="math-container">\[H^{\text{eff}} = H_0 + U \cdot G\]</p><p>where:</p><ul><li><p class="math-container">\[H_0\]</p>: one-body Hamiltonian (shape <span>$N \times N$</span>)</li><li><p class="math-container">\[U\]</p>: effective interaction matrix <span>$U_{(i,j),(k,l)}$</span> (shape <span>$N^2 \times N^2$</span>)</li><li><p class="math-container">\[G\]</p>: Green&#39;s function reshaped to a vector (length <span>$N^2$</span>)</li><li>Result: effective Hamiltonian matrix (shape <span>$N \times N$</span>)</li></ul><h2 id="Self-Consistent-Field-(SCF)-Iteration"><a class="docs-heading-anchor" href="#Self-Consistent-Field-(SCF)-Iteration">Self-Consistent Field (SCF) Iteration</a><a id="Self-Consistent-Field-(SCF)-Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Self-Consistent-Field-(SCF)-Iteration" title="Permalink"></a></h2><p>The Hartree-Fock equations are solved iteratively:</p><ol><li><p><strong>Initialize</strong>: Start with an initial guess for <span>$G_{ij}$</span> (random or from previous calculation)</p></li><li><p><strong>Build effective Hamiltonian</strong>: <span>$h^{\text{eff}} = t + U \cdot G$</span></p></li><li><p><strong>Diagonalize</strong>: Find eigenvalues <span>$\{\varepsilon_n\}$</span> and eigenvectors <span>$\{|n\rangle\}$</span> of <span>$h^{\text{eff}}$</span></p></li><li><p><strong>Update Green&#39;s function</strong>:</p><ul><li><p><strong>Zero temperature</strong>: Occupy lowest <span>$N_e$</span> states <span>$G_{ij} = \sum_{n=1}^{N_e} \langle i | n \rangle \langle n | j \rangle$</span></p></li><li><p><strong>Finite temperature</strong>: Use Fermi-Dirac distribution with chemical potential <span>$\mu$</span> <span>$G_{ij} = \sum_n f(\varepsilon_n - \mu) \langle i | n \rangle \langle n | j \rangle$</span> where <span>$f(\varepsilon) = 1/(e^{\varepsilon/T} + 1)$</span> and <span>$\mu$</span> is determined by particle number conservation</p></li></ul></li><li><p><strong>Check convergence</strong>: <span>$\text{Rest} = \frac{1}{N^2} \|G_{\text{new}} - G_{\text{old}}\|$</span></p><p>If <span>$\text{Rest} &lt; \epsilon$</span>, stop. Otherwise, mix and return to step 2: <span>$G \leftarrow (1-\alpha) G_{\text{old}} + \alpha G_{\text{new}}$</span></p></li><li><p><strong>Calculate physical quantities</strong>:</p><ul><li><strong>Band energy</strong>: <span>$E_{\text{band}} = \sum_i H^{\text{eff}}_{ii} G_{ii}$</span> (zero T) or use grand potential (finite T)</li><li><strong>Interaction energy</strong>: <span>$E_{\text{int}} = -\frac{1}{2} G^T \cdot U \cdot G$</span></li><li><strong>Total energy</strong>: <span>$E_{\text{total}} = E_{\text{band}} + E_{\text{int}}$</span></li><li><strong>Particle number</strong>: <span>$N = \sum_i G_{ii}$</span></li><li><strong>Spin polarization</strong>: <span>$S_z = \frac{1}{2} \sum_i (G_{i\uparrow,i\uparrow} - G_{i\downarrow,i\downarrow})$</span></li></ul></li></ol><h2 id="Implementation-Notes"><a class="docs-heading-anchor" href="#Implementation-Notes">Implementation Notes</a><a id="Implementation-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Notes" title="Permalink"></a></h2><h3 id="Recommended:-Direct-U-Matrix-Construction"><a class="docs-heading-anchor" href="#Recommended:-Direct-U-Matrix-Construction">Recommended: Direct U Matrix Construction</a><a id="Recommended:-Direct-U-Matrix-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended:-Direct-U-Matrix-Construction" title="Permalink"></a></h3><p><strong>For efficient Hartree-Fock calculations, use <code>build_U_matrix</code> to directly construct the sparse U matrix from operators:</strong></p><pre><code class="language-julia hljs">U_matrix = build_U_matrix(dofs, interaction_ops, blocks)</code></pre><p>This approach:</p><ul><li><strong>Skips the intermediate V tensor</strong> (saves N⁴ memory, e.g., 1.3 TB for 30×30 system)</li><li><strong>Directly generates sparse matrix</strong> representation</li><li><strong>Applies the 4-term formula</strong> during construction</li><li><strong>Exploits block structure</strong> when provided</li></ul><p>For each interaction operator <span>$V_{ijkl}$</span>, the function contributes to <strong>four U matrix elements</strong>:</p><pre><code class="language-julia hljs">U[(i-1)*N+j, (k-1)*N+l] += V[i,j,k,l]  # Hartree term 2
U[(k-1)*N+l, (i-1)*N+j] += V[i,j,k,l]  # Hartree term 1  (transpose)
U[(k-1)*N+j, (i-1)*N+l] -= V[i,j,k,l]  # Fock term 3     (exchange)
U[(i-1)*N+l, (k-1)*N+j] -= V[i,j,k,l]  # Fock term 4     (exchange)</code></pre><h3 id="Alternative:-Two-Step-Construction-via-V-Tensor"><a class="docs-heading-anchor" href="#Alternative:-Two-Step-Construction-via-V-Tensor">Alternative: Two-Step Construction via V Tensor</a><a id="Alternative:-Two-Step-Construction-via-V-Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative:-Two-Step-Construction-via-V-Tensor" title="Permalink"></a></h3><p>For debugging or small systems, you can use the two-step approach:</p><pre><code class="language-julia hljs">V = build_interaction_tensor(dofs, interaction_ops)  # Dense N×N×N×N tensor
# Then manually apply 4-term formula to build U</code></pre><p><strong>Note</strong>: This approach requires O(N⁴) memory and is <strong>not recommended for large systems</strong>.</p><h3 id="Symmetry-and-Blocking"><a class="docs-heading-anchor" href="#Symmetry-and-Blocking">Symmetry and Blocking</a><a id="Symmetry-and-Blocking-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-and-Blocking" title="Permalink"></a></h3><p>When the system has conserved quantum numbers (e.g., spin <span>$S_z$</span>, particle number), the effective Hamiltonian and Green&#39;s function can be block-diagonalized:</p><ul><li>Use <code>SystemDofs</code> with <code>sortrule = [[conserved_dof_indices], other_dofs]</code></li><li><code>blocks</code> field provides index ranges for each symmetry sector</li><li>Diagonalize each block independently for efficiency</li><li>Drastically reduces computational cost for large systems</li></ul><h3 id="Block-Structure-and-U-Matrix-Sparsification"><a class="docs-heading-anchor" href="#Block-Structure-and-U-Matrix-Sparsification">Block Structure and U Matrix Sparsification</a><a id="Block-Structure-and-U-Matrix-Sparsification-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Structure-and-U-Matrix-Sparsification" title="Permalink"></a></h3><p><strong>Important</strong>: The <code>blocks</code> parameter optimizes the U matrix construction by exploiting the block-diagonal structure of G, <strong>not</strong> by making U itself block-diagonal.</p><p><strong>Key insight</strong>: If G is block-diagonal (e.g., spin-up and spin-down blocks), then <span>$G_{kl} = 0$</span> when <span>$k$</span> and <span>$l$</span> are in different blocks. When computing:</p><p class="math-container">\[h^{\text{eff}}_{ij} = t_{ij} + \sum_{kl} U_{ijkl} G_{kl}\]</p><p>any <span>$U_{ijkl}$</span> term multiplied by <span>$G_{kl} = 0$</span> contributes nothing. Therefore, we can <strong>skip storing</strong> U matrix elements where <span>$(k,l)$</span> are in different blocks.</p><p><strong>Storage reduction</strong>: For B equal-sized blocks, this saves approximately <span>$(1 - 1/B^2)$</span> of memory and computation:</p><ul><li>2 spin blocks: <strong>75% reduction</strong></li><li>4 blocks: <strong>94% reduction</strong></li></ul><p><strong>Implementation</strong>: <code>build_U_matrix(dofs, ops, blocks)</code> only stores <span>$U_{(i,j),(k,l)}$</span> when <span>$(k,l)$</span> are in the same block, creating a column-sparse (not block-diagonal) matrix optimized for multiplication with block-diagonal G.</p><h2 id="Example:-Hubbard-Model"><a class="docs-heading-anchor" href="#Example:-Hubbard-Model">Example: Hubbard Model</a><a id="Example:-Hubbard-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Hubbard-Model" title="Permalink"></a></h2><p>For the single-band Hubbard model:</p><p class="math-container">\[H = -t \sum_{\langle ij \rangle, \sigma} c^\dagger_{i\sigma} c_{j\sigma} + U \sum_i n_{i\uparrow} n_{i\downarrow}\]</p><p>The on-site interaction <span>$U n_{i\uparrow} n_{i\downarrow} = U c^\dagger_{i\uparrow} c_{i\uparrow} c^\dagger_{i\downarrow} c_{i\downarrow}$</span> is implemented as:</p><pre><code class="language-julia hljs"># Setup system with spin blocking
dofs = SystemDofs([Dof(:site, N), Dof(:spin, 2)], sortrule = [[2], 1])
onsite = bonds(lattice, (:o, :o), 0)  # On-site bonds

# Generate Hubbard U operators
U_ops = generate_twobody(dofs, onsite,
    (delta, qn1, qn2, qn3, qn4) -&gt;
        (qn1.site == qn2.site == qn3.site == qn4.site) &amp;&amp;
        (qn1.spin, qn2.spin, qn3.spin, qn4.spin) == (1, 1, 2, 2) ? U : 0.0,
    order = (cdag, 1, c, 1, cdag, 1, c, 1)
)

# Build U matrix directly (recommended for large systems)
U_matrix = build_U_matrix(dofs, U_ops, dofs.blocks)

# In SCF iteration:
# H_eff = H_0 + reshape(U_matrix * vec(G), N, N)</code></pre><p>The <code>build_U_matrix</code> function automatically applies the mean-field 4-term formula and exploits the spin block structure for efficiency.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li>Hartree, D. R. (1928). &quot;The Wave Mechanics of an Atom with a Non-Coulomb Central Field&quot;</li><li>Fock, V. (1930). &quot;Näherungsmethode zur Lösung des quantenmechanischen Mehrkörperproblems&quot;</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantumsystem/">« Quantum System</a><a class="docs-footer-nextpage" href="../singlemode/">Single-Mode Approximation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 14:16">Friday 13 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
